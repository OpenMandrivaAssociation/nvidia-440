--- a/kernel/nvidia-uvm/uvm8_gpu_isr.c
+++ b/kernel/nvidia-uvm/uvm8_gpu_isr.c
@@ -25,6 +25,7 @@
 #include "uvm8_gpu_isr.h"
 #include "uvm8_hal.h"
 #include "uvm8_next_decl.h"
+#include <generated/uapi/linux/version.h>
 
 // For use by the nv_kthread_q that is servicing the replayable fault bottom
 // half, only.
@@ -270,7 +271,11 @@
 
 void uvm_gpu_replayable_faults_isr_unlock(uvm_gpu_t *gpu)
 {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+    UVM_ASSERT(atomic_read(&(gpu->gpu_kref.refcount.refs)) > 0);
+#else
     UVM_ASSERT(atomic_read(&gpu->gpu_kref.refcount) > 0);
+#endif
 
     uvm_spin_lock_irqsave(&gpu->isr.replayable_faults.interrupts_lock);
 

--- a/kernel/nvidia-uvm/uvm_linux.h
+++ b/kernel/nvidia-uvm/uvm_linux.h
@@ -32,6 +32,8 @@
 #ifndef _UVM_LINUX_H
 #define _UVM_LINUX_H
 
+#include <generated/uapi/linux/version.h>
+
 #include "nv-misc.h"
 #include "nvtypes.h"
 
@@ -64,6 +66,10 @@
 
 #if defined(NV_LINUX_RATELIMIT_H_PRESENT)
 #include <linux/ratelimit.h>
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+#include <linux/sched/signal.h>
 #endif
 
 // TODO: Bug 1772628: remove the "defined(NV_BUILD_SUPPORTS_HMM)" part,
@@ -206,6 +212,7 @@
     void address_space_init_once(struct address_space *mapping);
 #endif
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(4, 10, 0)
 #if !defined(NV_FATAL_SIGNAL_PENDING_PRESENT)
     static inline int __fatal_signal_pending(struct task_struct *p)
     {
@@ -216,6 +223,7 @@
     {
         return signal_pending(p) && __fatal_signal_pending(p);
     }
+#endif
 #endif
 
 // Develop builds define DEBUG but enable optimization

--- a/kernel/nvidia-drm/nvidia-drm-drv.c
+++ b/kernel/nvidia-drm/nvidia-drm-drv.c
@@ -48,6 +48,8 @@
 #include <drm/drm_auth.h>
 #endif
 
+#include <generated/uapi/linux/version.h>
+
 static struct nvidia_drm_device *dev_list = NULL;
 
 #if defined(NV_DRM_ATOMIC_MODESET_AVAILABLE)
@@ -71,12 +73,17 @@
 static struct drm_framebuffer *nvidia_drm_framebuffer_create(
     struct drm_device *dev,
     struct drm_file *file,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+    const struct drm_mode_fb_cmd2 *cmd
+)
+#else
     #if defined(NV_DRM_HELPER_MODE_FILL_FB_STRUCT_HAS_CONST_MODE_CMD_ARG)
     const struct drm_mode_fb_cmd2 *cmd
     #else
     struct drm_mode_fb_cmd2 *cmd
     #endif
     )
+#endif
 {
     struct drm_mode_fb_cmd2 local_cmd;
     struct drm_framebuffer *fb;
@@ -88,14 +95,20 @@
             file,
             &local_cmd, 0, 0);
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(4, 10, 0)
     #if !defined(NV_DRM_HELPER_MODE_FILL_FB_STRUCT_HAS_CONST_MODE_CMD_ARG)
     *cmd = local_cmd;
     #endif
+#endif
 
     return fb;
 }
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+struct drm_mode_config_funcs nv_mode_config_funcs = {
+#else
 static const struct drm_mode_config_funcs nv_mode_config_funcs = {
+#endif
     .fb_create = nvidia_drm_framebuffer_create,
 
 #if defined(NV_DRM_MODE_CONFIG_FUNCS_HAS_ATOMIC_STATE_ALLOC)
@@ -398,7 +411,11 @@
     return 0;
 }
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+static void nvidia_drm_unload(struct drm_device *dev)
+#else
 static int nvidia_drm_unload(struct drm_device *dev)
+#endif
 {
 #if defined(NV_DRM_ATOMIC_MODESET_AVAILABLE)
     struct NvKmsKapiDevice *pDevice = NULL;
@@ -412,7 +429,11 @@
 
     if (!nvidia_drm_modeset_enabled(dev))
     {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+        return;
+#else
         return 0;
+#endif
     }
 
     mutex_lock(&nv_dev->lock);
@@ -445,7 +466,11 @@
 
 #endif /* NV_DRM_ATOMIC_MODESET_AVAILABLE */
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+    return;
+#else
     return 0;
+#endif
 }
 
 #if defined(NV_DRM_ATOMIC_MODESET_AVAILABLE)

--- a/kernel/nvidia-drm/nvidia-drm-fb.c
+++ b/kernel/nvidia-drm/nvidia-drm-fb.c
@@ -21,6 +21,7 @@
  */
 
 #include "conftest.h" /* NV_DRM_ATOMIC_MODESET_AVAILABLE */
+#include <generated/uapi/linux/version.h>
 
 #if defined(NV_DRM_ATOMIC_MODESET_AVAILABLE)
 
@@ -152,7 +153,11 @@
 
     /* Fill out framebuffer metadata from the userspace fb creation request */
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+    drm_helper_mode_fill_fb_struct(dev, &nv_fb->base, cmd);
+#else
     drm_helper_mode_fill_fb_struct(&nv_fb->base, cmd);
+#endif
 
     /* Initialize the base framebuffer object and add it to drm subsystem */
 

--- a/kernel/nvidia-drm/nvidia-drm-encoder.h
+++ b/kernel/nvidia-drm/nvidia-drm-encoder.h
@@ -30,6 +30,9 @@
 #include "nvidia-drm-priv.h"
 
 #include <drm/drmP.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+#include <drm/drm_encoder.h>
+#endif
 #include "nvkms-kapi.h"
 
 struct nvidia_drm_encoder

--- a/kernel/nvidia-drm/nvidia-drm-gem.c
+++ b/kernel/nvidia-drm/nvidia-drm-gem.c
@@ -22,6 +22,8 @@
 
 #include "conftest.h" /* NV_DRM_ATOMIC_MODESET_AVAILABLE */
 
+#include <generated/uapi/linux/version.h>
+
 #if defined(NV_DRM_AVAILABLE)
 
 #include "nvidia-drm-priv.h"
@@ -511,11 +513,19 @@
  * Note that nvidia_drm_vma_fault() can be called for different or same
  * ranges of the same drm_gem_object simultaneously.
  */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+static int nvidia_drm_vma_fault(struct vm_fault *vmf)
+#else
 static int nvidia_drm_vma_fault(struct vm_area_struct *vma,
                                 struct vm_fault *vmf)
+#endif
 {
     unsigned long address = nv_page_fault_va(vmf);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+    struct drm_gem_object *gem = vmf->vma->vm_private_data;
+#else
     struct drm_gem_object *gem = vma->vm_private_data;
+#endif
     struct nvidia_drm_gem_object *nv_gem =
                     DRM_GEM_OBJECT_TO_NV_GEM_OBJECT(gem);
     unsigned long page_offset, pfn;
@@ -526,7 +536,11 @@
 
     page_offset = vmf->pgoff - drm_vma_node_start(&gem->vma_node);
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+    ret = vm_insert_pfn(vmf->vma, address, pfn + page_offset);
+#else
     ret = vm_insert_pfn(vma, address, pfn + page_offset);
+#endif
 
     switch (ret) {
         case 0:

--- a/kernel/nvidia-drm/nvidia-drm-linux.c
+++ b/kernel/nvidia-drm/nvidia-drm-linux.c
@@ -20,6 +20,8 @@
  * DEALINGS IN THE SOFTWARE.
  */
 
+#include <generated/uapi/linux/version.h>
+
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/err.h>
@@ -185,7 +187,11 @@
 module_exit(nv_linux_drm_exit);
 
 #if defined(MODULE_LICENSE)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+  MODULE_LICENSE("Dual MIT/GPL");
+#else
   MODULE_LICENSE("MIT");
+#endif
 #endif
 #if defined(MODULE_INFO)
   MODULE_INFO(supported, "external");

--- a/kernel/nvidia-uvm/uvm_common.c
+++ b/kernel/nvidia-uvm/uvm_common.c
@@ -25,6 +25,8 @@
  * This file contains code that is common to all variants of the (Linux) UVM
  * kernel module.
  */
+
+#include <generated/uapi/linux/version.h>
 
 #include "uvm_common.h"
 #include "uvm_linux.h"
@@ -388,5 +390,9 @@
 MODULE_PARM_DESC(uvm_enable_builtin_tests,
                  "Enable the UVM built-in tests. (This is a security risk)");
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+MODULE_LICENSE("Dual MIT/GPL");
+#else
 MODULE_LICENSE("MIT");
+#endif
 MODULE_INFO(supported, "external");

--- a/kernel/nvidia-modeset/nvidia-modeset-linux.c
+++ b/kernel/nvidia-modeset/nvidia-modeset-linux.c
@@ -22,6 +22,8 @@
 #include <linux/random.h>
 #include <linux/file.h>
 #include <linux/list.h>
+
+#include <generated/uapi/linux/version.h>
 
 #include "nvstatus.h"
 
@@ -1285,7 +1287,11 @@
 module_exit(nvkms_exit);
 
 #if defined(MODULE_LICENSE)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+  MODULE_LICENSE("GPL");
+#else
   MODULE_LICENSE("NVIDIA");
+#endif
 #endif
 #if defined(MODULE_INFO)
   MODULE_INFO(supported, "external");

